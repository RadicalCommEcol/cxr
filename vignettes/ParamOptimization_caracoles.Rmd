---
title: "Multi-species parameter optimization"
output: rmarkdown::html_vignette
author: cxr team
vignette: >
  %\VignetteIndexEntry{Multi-species parameter optimization}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

**Introduction**

In this document, we explain how to perform a complete analysis on a plant community. The aim is to use field data to obtain the parameterization of a model of the form: 

$F = \frac{\lambda}{1+\alpha}$

which will allow us to analyze the interaction matrix, the effect of environmental or biotic covariates, and in turn, different outcomes regarding the coexistence patterns between species. Most of the vignette will be dedicated to prepare the data from what is obtained in the field to the appropriate format for the analysis. 

**Setup**

We start loading the package and the associated dataset. We set up 9 plots [...]. We will use the following data:
- \code{competition}: measurement of fruit and seed set of plant individuals in presence of competitors of the same or other species.
- \code{salinity}: soil salinity for each subplot.

```{r}
library(cxr)
data(competition)
data(salinity)
```

**Preparing the data**

We need to 1) build a data structure that will hold the results for all species, and 2) prepare the field data for the analysis.

```{r}
# spread the data from long to wide format
competition.data <- tidyr::spread(competition,competitor,number,fill = 0)
# how many focal species
focal.sp <- unique(competition.data$focal)
# obtain the competition matrix
comp.matrix <- as.matrix(competition.data[,10:ncol(competition.data)])

# the rows in the covariates datasets (salinity, in our example) must match the observations of the competition dataset.
# in order to be sure that they match, join them in a single dataset (note that they share a unique identifier, given by plot+subplot+year)
full.data <- dplyr::left_join(competition.data,salinity)

```

Now, we set some general variables regarding the models we want to use, and the parameters we want to estimate.
Note that if we include more than one model, the optimization procedures proceed sequentially; e.g., if we estimate parameters from models 3, 4, and 5

```{r}
models <- 3:5
```

the output from model 3 will be taken as initial estimates for model 4, and the output from model 4 will be the initial estimates for model 5. Note, as well, that models 4 and 5 differ from model 3 in that they include the effect of covariates on species fecundity and interactions. Therefore, you should only include these models if you have at least one covariate in your data (see Lanuza et al. 2018).

We can estimate the whole parameter set for each model, or fix certain parameters, for example, if we have independent field estimates of them. This information is passed to the function in a list, in which each element is a string vector giving the set of parameters that are to be optimized for each model. In our example, we optimize all parameters (note that model 3 has only $\lambda$ and $\alpha$ parameters, whereas models 4 and 5 also include the effect of covariates).

```{r}
# which values do we optimize for each model?
param.list <- list(c("lambda","alpha"),
                   c("lambda","alpha","lambda.cov","alpha.cov"),
                   c("lambda","alpha","lambda.cov","alpha.cov"))
```

In case you had independent estimates of parameters, you would have something along these lines:

```{r}
# init.lambda <- rep(1,length(focal.sp))
# init.alpha <- matrix(rnorm(ncol(comp.matrix)*ncol(comp.matrix),1,0.01),nrow = ncol(comp.matrix),ncol = ncol(comp.matrix))
```

Keep the model definitions in a list, for ease:

```{r}
fitness.models <- list(BH_1 = BH_1,BH_2 = BH_2,BH_3 = BH_3,BH_4 = BH_4,BH_5 = BH_5)
```

Get back the covariates, after matching with the competition observations. It is important that covariates are passed in a matrix format. If they are named, the output will also include the names.

```{r}
# environmental covariates
covariates <- as.matrix(full.data[,"sum_salinity"])
colnames(covariates) <- "sum_salinity"
# if no covariates, comment above and uncomment here
# covariates <- 0
```

Here we specify which optimization methods to use. You can include more than one.

```{r}
# optimization methods to use
optim.methods <- c("optim_NM"
                   # "optim_L-BFGS-B"
                  # "nloptr_CRS2_LM"
                   # "nloptr_ISRES"
                   # "nloptr_DIRECT_L_RAND"
                    # "GenSA"
                   # "hydroPSO"
                   # "DEoptimR"
)
```

Since the routine takes the input for a given model from the output of the previous model, we need to specifiy, if we selected more than one optimization method, from which method it will take these initial values:

```{r}
# from which method are we taking initial estimates for the next model?
init.par.method <- optim.methods[1]
init.method.num <- which(optim.methods == init.par.method)
```

We also need to specify the initial values for the first model (model 3, in this example). If you have independent estimates of any parameter, comment out the appropriate lines. Note that some of the optimization methods (e.g. optim-LFGS-B) fail with lower bounds equal to zero. Hence the small, but positive, values.

```{r}
# values for initial estimates of parameters. 
# Overwrite if necessary
# init.lambda is calculated after log.fitness for each focal species
lower.lambda <- 1
upper.lambda <- 1e4
# sigma
lower.sigma <- 1e-5
upper.sigma <- 1
# alpha
init.alpha <- 1e-4
lower.alpha <- 1e-10
upper.alpha <- 1e5
# lambda.cov
init.lambda.cov <- 1
lower.lambda.cov <- 1e-10
upper.lambda.cov <- 1e4
# alpha.cov
init.alpha.cov <- 1
lower.alpha.cov <- 1e-10
upper.alpha.cov <- 1e4
```

The package can also compute the standard errors of the estimation, via bootstrapping. This can be, depending on the model and optimization method, computationally expensive. Here we provide a minimal example of it.

```{r}
generate.errors <- TRUE
bootstrap.samples <- 3
```

And a flag for storing or not the results of the analysis

```{r}
# store results?
write.results <- FALSE
```

**Initialize results structure** 

We will store the results of our analysis in a nested list, following the nested design of the experiment. For each focal species, we calculate three different models (given in \code{models}), and for each of these models, we obtain the parameterization from a series of optimization methods (given in \code{optim.methods}). Thus, we create a list, named \code{param_estimates}, of the form:

\code{param_estimates[[species]][[model]][[method]]}

This is done with a series of nested loops:

```{r}
param_estimates <- list()
for(i.sp in 1:length(focal.sp)){
  param_estimates[[i.sp]] <- list()
  for(i.model in 1:length(models)){
    param_estimates[[i.sp]][[i.model]] <- list()
    for(i.method in 1:length(optim.methods)){
      param_estimates[[i.sp]][[i.model]][[i.method]] <- list(lambda = 0,
                                                            lambda.lower.error = 0,
                                                            lambda.upper.error = 0,
                                                            sigma = 0,
                                                            alpha = 0,
                                                            alpha.lower.error = 0,
                                                            alpha.upper.error = 0,
                                                            lambda.cov = 0,
                                                            lambda.cov.lower.error = 0,
                                                            lambda.cov.upper.error = 0,
                                                            alpha.cov = 0,
                                                            alpha.cov.lower.error = 0,
                                                            alpha.cov.upper.error = 0,
                                                            log.likelihood = 0)
    }
    names(param_estimates[[i.sp]][[i.model]]) <- optim.methods
  }
  names(param_estimates[[i.sp]]) <- names(fitness.models)[models]
}
names(param_estimates) <- focal.sp
```

Now, we are ready to go, species by species, performing the analysis. As the main function, \code{cxr_optimize}, accepts the input for a single species, we code a loop for going through all species. Inside this loop, we include the following steps:
- 1) subset the competition data for the focal species 
- 2) generate the actual initial values, considering all situations. Remember that, depending on the model, some parameters will have different length. For example, $\alpha$ is a single value in model 2 and a matrix in model 3 onwards. Thus, for species *i*, $alpha_{ij}$ is a vector of length equal to the number of competitor species.
- 3) the actual call to \code{cxr_optimize}
- 4) store the results in the nested list we created above
- 5) update the initial values to be passed on to the next model

```{r echo=FALSE}
for(i.sp in 1:length(focal.sp)){
  
  # 1) subset and prepare the data
  
  focal.sp.data <- subset(competition.data, focal == focal.sp[i.sp])
  # current focal species
  focal <- unique(focal.sp.data$focal)
  # fitness metric...
  # subset >0 records, for calculating logarithms
  focal.sp.data <- subset(focal.sp.data, seed > 0)
  fitness <- focal.sp.data$seed #fitness
  log.fitness <- log(fitness)
  # competition matrix: number of competitors
  focal.comp.matrix <- comp.matrix[which(competition.data$focal == focal.sp[i.sp]),]
  # number of competitors
  num.competitors <- dim(focal.comp.matrix)[2]
  # number of covariates
  num.covariates <- ifelse(is.null(ncol(covariates)),0,ncol(covariates))
  # covariates for the focal species
  if(num.covariates > 0){
    focal.covariates <- covariates[which(competition.data$focal == focal.sp[i.sp]),,drop = FALSE]
  }else{
    focal.covariates <- 0
  }
  
  # 2) generate initial values for the different parameters
  # or gather them from data if they are not to be optimized
  
  # lambda
  if("lambda" %in% unlist(param.list)){
    current.init.lambda <- mean(log.fitness)
  }else{
    current.init.lambda <- init.lambda[i.sp]
  }
  # sigma
  current.init.sigma <- sd(log.fitness)
  if(current.init.sigma > upper.sigma){
    current.init.sigma <- upper.sigma
  }
  # alpha
  if("alpha" %in% unlist(param.list)){
    if(models[1]<=2){
      alpha.length <- 1
    }else{
      alpha.length <- num.competitors
    }
    if(length(init.alpha) != alpha.length){
     current.init.alpha <- rep(init.alpha[1],alpha.length) 
    }else{
      current.init.alpha <- init.alpha
    }
  }else{
    current.init.alpha <- init.alpha[i.sp,]
  }
  # lambda.cov
  if("lambda.cov" %in% unlist(param.list)){
    if(length(init.lambda.cov) != num.covariates){
      current.init.lambda.cov <- rep(init.lambda.cov[1],num.covariates)
    }else{
      current.init.lambda.cov <- init.lambda.cov  
    }
  }else{
    current.init.lambda.cov <- init.lambda.cov[i.sp]  
  }
  # alpha.cov
  if("alpha.cov" %in% unlist(param.list)){
    if(models[1]<=4){
      length.alpha.cov <- num.covariates
    }else if(models[1]>4){
      length.alpha.cov <- num.covariates*num.competitors
    }
    if(length(init.alpha.cov) != length.alpha.cov){
      current.init.alpha.cov <- rep(init.alpha.cov[1],length.alpha.cov)
    }else{
      current.init.alpha.cov <- init.alpha.cov  
    }  
  }else{
    current.init.alpha.cov <- init.alpha.cov[i.sp]  
  }
  
  # model to optimize  
  for(i.model in 1:length(models)){
    
    # print("*********************************")
    # print(paste(date()," - starting focal sp ",focal.sp[i.sp],", model ",models[i.model],sep=""))
    # print("*********************************")

    ######################
    # 3) compute each method
    
    for(i.method in 1:length(optim.methods)){
      
      temp.results <- cxr_optimize(fitness.model = fitness.models[[models[i.model]]],
                                   optim.method = optim.methods[i.method],
                                   param.list = param.list[[i.model]],
                                   log.fitness = log.fitness,
                                   init.lambda = current.init.lambda,
                                   lower.lambda = lower.lambda,
                                   upper.lambda = upper.lambda,
                                   init.sigma = current.init.sigma,
                                   lower.sigma = lower.sigma,
                                   upper.sigma = upper.sigma,
                                   init.alpha = current.init.alpha,
                                   lower.alpha = lower.alpha,
                                   upper.alpha = upper.alpha,
                                   init.lambda.cov = current.init.lambda.cov,
                                   lower.lambda.cov = lower.lambda.cov,
                                   upper.lambda.cov = upper.lambda.cov,
                                   init.alpha.cov = current.init.alpha.cov,
                                   lower.alpha.cov = lower.alpha.cov,
                                   upper.alpha.cov = upper.alpha.cov,
                                   focal.comp.matrix = focal.comp.matrix,
                                   focal.covariates = focal.covariates,
                                   generate.errors = generate.errors,
                                   bootstrap.samples = bootstrap.samples,verbose = TRUE)
      ###############
      # 4) store results
      
      param_estimates[[i.sp]][[i.model]][[i.method]]$lambda <- temp.results$lambda
      param_estimates[[i.sp]][[i.model]][[i.method]]$lambda.lower.error <- temp.results$lambda.lower.error
      param_estimates[[i.sp]][[i.model]][[i.method]]$lambda.upper.error <- temp.results$lambda.upper.error
      
      param_estimates[[i.sp]][[i.model]][[i.method]]$sigma <- temp.results$sigma
      
      param_estimates[[i.sp]][[i.model]][[i.method]]$alpha <- temp.results$alpha
      param_estimates[[i.sp]][[i.model]][[i.method]]$alpha.upper.error <- temp.results$alpha.upper.error
      param_estimates[[i.sp]][[i.model]][[i.method]]$alpha.lower.error <- temp.results$alpha.lower.error
      
      param_estimates[[i.sp]][[i.model]][[i.method]]$lambda.cov <- temp.results$lambda.cov
      param_estimates[[i.sp]][[i.model]][[i.method]]$lambda.cov.upper.error <- temp.results$lambda.cov.upper.error
      param_estimates[[i.sp]][[i.model]][[i.method]]$lambda.cov.lower.error <- temp.results$lambda.cov.lower.error
      
      param_estimates[[i.sp]][[i.model]][[i.method]]$alpha.cov <- temp.results$alpha.cov
      param_estimates[[i.sp]][[i.model]][[i.method]]$alpha.cov.upper.error <- temp.results$alpha.cov.upper.error
      param_estimates[[i.sp]][[i.model]][[i.method]]$alpha.cov.lower.error <- temp.results$alpha.cov.lower.error
      
      param_estimates[[i.sp]][[i.model]][[i.method]]$log.likelihood <- temp.results$log.likelihood
      
    }# for i.method
    
    #######################
    # 5) update initial values for the next model, if there is one
    
    # lambda
    if(i.model < length(param.list)){
      if("lambda" %in% param.list[[i.model+1]]){
        if(!is.na(param_estimates[[i.sp]][[i.model]][[init.par.method]]$lambda)){
          current.init.lambda <- param_estimates[[i.sp]][[i.model]][[init.par.method]]$lambda
        }
      }
      # sigma
      if(!is.na(param_estimates[[i.sp]][[i.model]][[init.par.method]]$sigma)){
        current.init.sigma <- param_estimates[[i.sp]][[i.model]][[init.par.method]]$sigma
        if(current.init.sigma > upper.sigma){
          current.init.sigma <- upper.sigma
        }
      }
      # alpha
      if("alpha" %in% param.list[[i.model+1]]){
        if(sum(is.na(param_estimates[[i.sp]][[i.model]][[init.par.method]]$alpha)) == 0){
          current.init.alpha <- param_estimates[[i.sp]][[i.model]][[init.par.method]]$alpha
          # is the current estimate of the appropriate length?
          if(models[i.model+1] > 2){
            if(length(current.init.alpha) == 1){
              current.init.alpha <- rep(current.init.alpha,num.competitors)
            }
          }# if model > 2
        }
      }
      # lambda.cov
      if("lambda.cov" %in% param.list[[i.model+1]]){
        if(sum(is.na(param_estimates[[i.sp]][[i.model]][[init.par.method]]$lambda.cov)) == 0){
          current.init.lambda.cov <- param_estimates[[i.sp]][[i.model]][[init.par.method]]$lambda.cov
        }
      }
      # alpha.cov
      if("alpha.cov" %in% param.list[[i.model+1]]){
        if(sum(is.na(param_estimates[[i.sp]][[i.model]][[init.par.method]]$alpha.cov)) == 0){
          current.init.alpha.cov <- param_estimates[[i.sp]][[i.model]][[init.par.method]]$alpha.cov
          # is the current estimate of the appropriate length?
          if(models[i.model+1] > 4){
            if(length(current.init.alpha.cov) == num.covariates){
              current.init.alpha.cov <- rep(current.init.alpha.cov,num.competitors)
            }
          }# if model > 4
        }
      }# alpha.cov
    }# if still models to run
  }# for i.model
}# for i.sp

```

If we set the flag, the nested list will be written to disk as a .RData file. The list structure is very convenient for handling these results in R, as it maintains the nested design of the parameterization (per species, model, and optimization method). However, it may also be necessary to have the results as dataframes and csv files, e.g. for plotting. Here we build four dataframes, in long format, for the different sets of parameters: lambda, alpha, lambda.cov, and alpha.cov. This assumes that covariates are named, so the vectors returned from the list are also named.

```{r}
if(write.results){
  # save(param_estimates,file = "./results/param_estimates.Rdata")
  
  # just in case it is a factor
  focal.sp <- sort(as.character(focal.sp))
  competitors <- sort(names(param_estimates[[1]][[names(fitness.models)[models[models == max(models)]]]][[1]]$alpha))
  my.models <- names(fitness.models)[models]
  my.covariates <- c("sum_salinity")
  
  # lambda
  lambda.values <- expand.grid(focal.sp,my.models,optim.methods)
  names(lambda.values) <- c("species","model","method")
  lambda.values$lambda <- 0
  lambda.values$lambda.lower <- 0
  lambda.values$lambda.upper <- 0
  
  # alpha
  alpha.values <- expand.grid(focal.sp,competitors,my.models,optim.methods)
  names(alpha.values) <- c("focal","competitor","model","method")
  alpha.values$alpha <- 0
  alpha.values$alpha.lower <- 0
  alpha.values$alpha.upper <- 0
  
  # lambda.cov
  lambda.cov.values <- expand.grid(focal.sp,my.models,optim.methods,my.covariates)
  names(lambda.cov.values) <- c("species","model","method","covariate")
  lambda.cov.values$lambda.cov <- 0
  lambda.cov.values$lambda.cov.lower <- 0
  lambda.cov.values$lambda.cov.upper <- 0
  
  # alpha.cov
  alpha.cov.values <- expand.grid(focal.sp,competitors,my.models,optim.methods,my.covariates)
  names(alpha.cov.values) <- c("focal","competitor","model","method","covariate")
  alpha.cov.values$alpha.cov <- 0
  alpha.cov.values$alpha.cov.lower <- 0
  alpha.cov.values$alpha.cov.upper <- 0
  
  # fill up the dataframes
  for(i.sp in 1:length(focal.sp)){
    for(i.model in 1:length(my.models)){
      for(i.method in 1:length(optim.methods)){

        # lambda
        lambda.pos <- which(lambda.values$species == focal.sp[i.sp] &
                              lambda.values$model == my.models[i.model] &
                              lambda.values$method == optim.methods[i.method])
        lambda.values$lambda[lambda.pos] <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$lambda
        lambda.values$lambda.lower[lambda.pos] <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$lambda.lower.error
        lambda.values$lambda.upper[lambda.pos] <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$lambda.upper.error

        # alpha
        my.alpha.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$alpha
        my.alpha.lower.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$alpha.lower.error
        my.alpha.upper.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$alpha.upper.error

        alpha.pos <- which(alpha.values$focal == focal.sp[i.sp] &
                                alpha.values$model == my.models[i.model] &
                                alpha.values$method == optim.methods[i.method] &
                                alpha.values$competitor %in% names(my.alpha.vector))

        alpha.values$alpha[alpha.pos] <- my.alpha.vector
        alpha.values$alpha.lower[alpha.pos] <- my.alpha.lower.vector
        alpha.values$alpha.upper[alpha.pos] <- my.alpha.upper.vector

        # lambda.cov
        my.lambda.cov.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$lambda.cov
        my.lambda.cov.lower.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$lambda.cov.lower.error
        my.lambda.cov.upper.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$lambda.cov.upper.error
        
        # all covariates at once, should be ok
        lambda.cov.pos <- which(lambda.cov.values$species == focal.sp[i.sp] &
                                  lambda.cov.values$model == my.models[i.model] &
                                  lambda.cov.values$method == optim.methods[i.method])

        lambda.cov.values$lambda.cov[lambda.cov.pos] <- my.lambda.cov.vector
        lambda.cov.values$lambda.cov.lower[lambda.cov.pos] <- my.lambda.cov.lower.vector
        lambda.cov.values$lambda.cov.upper[lambda.cov.pos] <- my.lambda.cov.upper.vector

        # alpha.cov
        my.alpha.cov.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$alpha.cov
        my.alpha.cov.lower.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$alpha.cov.lower.error
        my.alpha.cov.upper.vector <- param_estimates[[focal.sp[i.sp]]][[my.models[i.model]]][[optim.methods[i.method]]]$alpha.cov.upper.error
        
        my.alpha.cov.comp <- substr(names(my.alpha.cov.vector),str_length(names(my.alpha.cov.vector))-3,str_length(names(my.alpha.cov.vector)))
        
        for(i.covariate in 1:length(my.covariates)){
          my.cov <- my.alpha.cov.vector[which(grepl(my.covariates[i.covariate],names(my.alpha.cov.vector)))]
          my.lower.cov <- my.alpha.cov.lower.vector[which(grepl(my.covariates[i.covariate],names(my.alpha.cov.lower.vector)))]
          my.upper.cov <- my.alpha.cov.upper.vector[which(grepl(my.covariates[i.covariate],names(my.alpha.cov.upper.vector)))]
          
          alpha.cov.pos <- which(alpha.cov.values$focal == focal.sp[i.sp] &
                                   alpha.cov.values$model == my.models[i.model] &
                                   alpha.cov.values$method == optim.methods[i.method] &
                                   alpha.cov.values$competitor %in% my.alpha.cov.comp & 
                                   alpha.cov.values$covariate == my.covariates[i.covariate])
          
          alpha.cov.values$alpha.cov[alpha.cov.pos] <- my.cov
          alpha.cov.values$alpha.cov.lower[alpha.cov.pos] <- my.lower.cov
          alpha.cov.values$alpha.cov.upper[alpha.cov.pos] <- my.upper.cov
        }

      }# for each method
    }# for each model
  }# for each sp
  
  # write.csv(lambda.values,file = "./results/lambda_values.csv",sep = ";")
  # write.csv(lambda.values,file = "./results/alpha_values.csv",sep = ";")
  # write.csv(lambda.values,file = "./results/lambda_cov_values.csv",sep = ";")
  # write.csv(lambda.values,file = "./results/alpha_cov_values.csv",sep = ";")
  
}
```

