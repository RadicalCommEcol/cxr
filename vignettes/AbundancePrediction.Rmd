---
title: "Predicting short-term variations in species abundances"
output: rmarkdown::html_vignette
author: cxr team
vignette: >
  %\VignetteIndexEntry{Multi-species parameter optimization}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

Another feature of \code{cxr} is the projection of population abundances in time given a population dynamics model and a set of parameters. This feature is available for models with the same set of parameters as the ones provided (i.e. **lambda**, **alpha**, **lambda.cov**, and **alpha.cov**). In the package we include a version of the five Beverton-Holt fecundity models, but users are encouraged to code their own predictive models.

In this document, we exemplify the use of our projection function. We project the abundances of a set of species from a simulated dataset. We use simulated data to show the usage of the function \code{GenerateTestData}, also included in the package.

First, load the package

```{r}
library(cxr)
```

Specify basic information: how many timesteps are we projecting, and the details of the data we are going to simulate

```{r}
# timesteps
timesteps <- 50

# test data
focal.sp <- c(1,2)
num.sp <- 5
num.cov <- 2
num.obs <- 3 # sites, per focal species

focal.lambda <- c(100,200)
alpha.matrix.orig <- matrix(data = runif(num.sp*num.sp,0.002,0),nrow = num.sp, ncol = num.sp)
lambda.cov.orig <- matrix(rnorm(num.sp*num.cov,0,0.005),nrow = num.sp, ncol = num.cov)
alpha.cov.orig <- list()
for(i.cov in 1:num.cov){
    alpha.cov.orig[[i.cov]] <- matrix(data = rnorm(num.sp*num.sp,0,0.005),nrow = num.sp, ncol = num.sp) 
}

```

With the above info on number of species, covariates, observations, and the associated parameters, we may call the function for generating simulated data. We also need to specify a generative fitness model, that should be one of the five variants of the Beverton-Holt fecundity models included in the package. Here we use the most complex one, model 5. Note also the structure of \code{lambda.cov} and \code{alpha.cov}. The effect of covariates on lambda values, \code{lambda.cov}, is a matrix of dimensions num.sp x num.cov. The effect of covariates on the alpha matrix, in turn, is a list with as many elements as covariates, where each element i of the list is (for model 5), a matrix of num.sp x num.sp, giving the effect of covariate i over each element of the interaction matrix.

```{r}
test.data <- GenerateTestData(focal.sp = focal.sp,
                              num.sp = num.sp,
                              num.cov = num.cov,
                              num.obs = num.obs,
                              fitness.model = 5,
                              focal.lambda = focal.lambda,
                              alpha.matrix = alpha.matrix.orig,
                              alpha.cov = alpha.cov.orig,
                              lambda.cov = lambda.cov.orig)
```

We also need to specify the seed survival and germination rates, in order to project the abundances of adult individuals

```{r}
# lambda, s, g
sp.par <- data.frame(species = 1:num.sp,lambda = 0,germ.rate = 0, survival.rate = 0)
sp.par$lambda[focal.sp] <- focal.lambda
sp.par$germ.rate[focal.sp] <- runif(length(focal.sp),0,0.5)
sp.par$survival.rate[focal.sp] <- runif(length(focal.sp),0,0.5)
```

and set the initial abundances. The \code{PredictAbundances} function is able to project populations from any number of independent sites. These will be treated as disconnected populations, but will share the species parameterization.

```{r}
# initial abundances
init.abund <- expand.grid(1:num.obs,1:num.sp)
names(init.abund) <- c("site","species")
init.abund$abundance <- rnorm(nrow(init.abund),100,50)
```

We also specify stochastic environmental covariates and their value for the timesteps projected

```{r}
# environmental heterogeneity
cov.time <- expand.grid(1:num.obs,1:timesteps,1:num.cov)
names(cov.time) <- c("site","timestep","covariate")
cov.time$value <- runif(nrow(cov.time),0,10)
```

put together all parameters for calling the function

```{r}
# effect of covariates on alpha and lambda
lambda.cov.matrix <- matrix(unlist(lambda.cov.orig),nrow = num.sp)

alpha.cov.matrix <- list()
for(i.cov in 1:num.cov){
  alpha.cov.matrix[[i.cov]] <- matrix(nrow = num.sp,ncol = num.sp)
  for(i.sp in 1:num.sp){
    alpha.cov.matrix[[i.cov]][i.sp,] <- alpha.cov.orig[[i.sp]][,i.cov]
  }
}

par <- list(sp.par = sp.par, 
            initial.values = init.abund, 
            covariates = cov.time, 
            other.par = list(alpha.matrix = alpha.matrix.orig, 
                             lambda.cov.matrix = lambda.cov.matrix, 
                             alpha.cov.matrix = alpha.cov.matrix))

abundance.model <- BH_abundance_5
```

In this simple set up, we choose to predict the number of seeds, instead of number of individuals. See the help from e.g. \code{BH_abundance_5} for details.

```{r}
predicted.abundances <- PredictAbundances(par = par,
                                          timesteps = timesteps,
                                          abundance.model = abundance.model,
                                          return.seeds = TRUE)
```

As an example, a very simple plot showing the temporal trend in see abundances

```{r}
predicted.abundances$timestep <- as.factor(predicted.abundances$timestep)
predicted.abundances$site <- as.factor(predicted.abundances$site)
predicted.abundances$sp <- as.factor(predicted.abundances$sp)

abund.plot <- ggplot2::ggplot(predicted.abundances,aes(x = timestep,y = abundance, group = sp)) + 
  ggplot2::geom_line(aes(color = sp)) + 
  ggplot2::facet_grid(site~.)+
  NULL
abund.plot
```

