---
title: "Obtain competitive responses and effects"
output: rmarkdown::html_vignette
author: cxr team
vignette: >
  %\VignetteIndexEntry{Multi-species parameter optimization}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

**Introduction**

In this example we calculate per-species competitive responses and effects, as outlined in Godoy et al. (2014), for the plant species included in the associated data. We will also use per-germinant fecundity estimates ($\lambda$) generated independently, as fixed parameters.

**Set up**

```{r}
library(cxr)
data(competition)
```

As in other vignettes, we need to specify which optimization method are we using, and whether we want to generate standard errors from bootstrapping.

```{r}
optim.methods <- c("optim_NM"
                   # "optim_L-BGFS-B",
                   # "nloptr_CRS2_LM", 
                   # "nloptr_ISRES", 
                   # "nloptr_DIRECT_L_RAND", 
                   # "GenSA"
                   # "hydroPSO", 
                   # "DEoptimR"
)

# if we want quick calculations, we can disable 
# the bootstrapping for the standard errors
generate.errors <- FALSE
bootstrap.samples <- 99 # discarded if false
```

Since we have independent estimates for $\lambda$, we are taking it as a fixed parameter that we do not want to fit. This can be passed on to the \code{ER_optimize} function by choosing the appropriate effect/response model. Note that, if we are not interested in fitting $\lambda$, we can dispense with specifying lower/upper bounds for it.

```{r}
optimize.lambda <- FALSE
# model is different...
if(optimize.lambda){
  effect.response.model <- EffectResponse_lambda
  lambda.lower.bound <- 0
  lambda.upper.bound <- 1e3
}else{
  effect.response.model <- EffectResponse
  lambda.lower.bound <- NA
  lambda.upper.bound <- NA
}
```

Finally, a flag for writing results or not

```{r}
write.results <- FALSE
```

It is possible to estimate, alongside competitive effects and responses, the effect of covariates over these terms. For simplicity, we will assume no effect of covariates in this example, but their addition is similar to the workflow exemplified in the vignette \code{Multi-species parameter optimization}. The dataset included with the package includes observations from 2016, but here we provide general code for any number of years (or sampling campaigns). We group observations in year x site records, where a site is a subplot within a specific plot (e.g. subplot A1 of plot 1).

```{r}
sp.data <- competition.data %>% group_by(year,plot,subplot,focal,competitor) %>% summarise(seed = sum(seed),number = sum(number))
names(sp.data)[which(names(sp.data) == "seed")] <- "fitness"
sp.data$site <- paste(sp.data$year,sp.data$plot,sp.data$subplot,sep="_")
sp.data <- sp.data[,c("site","focal","fitness","competitor","number")]

# this is the set of species we are fitting
sp.names <- sort(unique(sp.data$focal))
```

For the \code{ER_optimize} function to work properly, the dataset must be complete, with explicit zeros if a combination focal.sp-competitor was not observed in a given record. In case the sp.data dataframe does not include explicit missing competitors, here is a somewhat convoluted way for setting zeros to it so that for each focal sp, all competitor sp are included. 
```{r}
sites <- unique(sp.data$site)

missing.data <- sp.data
missing.data$site <- "0"
missing.data$focal <- "0"
missing.data$fitness <- 0
missing.data$competitor <- "0"
missing.data$number <- 0
# just in case it overflows
missing.data <- rbind(missing.data,missing.data,missing.data)
count <- 1

for(i.site in 1:length(sites)){
  for(i.sp in 1:length(sp.names)){
    my.competitors <- unique(sp.data$competitor[sp.data$site == sites[i.site] & sp.data$focal == sp.names[i.sp]])
    if(length(my.competitors) > 0 & length(my.competitors) < length(sp.names)){
      my.fitness <- sp.data$fitness[sp.data$site == sites[i.site] & sp.data$focal == sp.names[i.sp]][1]
      
      missing.competitors <- sp.names[which(!sp.names %in% my.competitors)]
      for(i.com in 1:length(missing.competitors)){
        
        missing.data$site[count] <- sites[i.site]
        missing.data$focal[count] <- sp.names[i.sp]
        missing.data$fitness[count] <- my.fitness
        missing.data$competitor[count] <- missing.competitors[i.com]
        missing.data$number[count] <- 0
        
        count <- count + 1
      }# for each missing
    }# if any missing
  }# for i.sp
}# for i.site

missing.data <- droplevels(subset(missing.data,competitor != "0"))

sp.data <- rbind(sp.data,missing.data)
sp.data <- arrange(sp.data, focal, site, competitor)
```

Discard focal species with no seeds

```{r}
sp.data <- droplevels(subset(sp.data, fitness > 0))
```

Get independent $\lambda$ values and append them to a dataframe

```{r}
data(param_estimates)

lambda.values <- data.frame(sp = sp.names,lambda = 0, sigma = 0)

# from which model and optimization method are we taking estimates?
estimates.model <- "BH_5" #Beverton-holt model number 5
estimates.method <- "optim_NM"

# gather lambda from fitted data
for(i.sp in 1:length(sp.names)){
  if(!is.null(param.matrices[[sp.names[i.sp]]])){
    lambda.values$lambda[lambda.values$sp == sp.names[i.sp]] <- param.matrices[[sp.names[i.sp]]][[estimates.model]][[estimates.method]]$lambda
    lambda.values$sigma[lambda.values$sp == sp.names[i.sp]] <- param.matrices[[sp.names[i.sp]]][[estimates.model]][[estimates.method]]$sigma
  }
}

# sanity check
lambda.values <- dplyr::arrange(subset(lambda.values, sp %in% sp.data$focal),sp.names)
# sigma is also a parameter
sigma <- mean(lambda.values$sigma)
```

Ensure that we only include species that have proper estimates

```{r}
sp.data <- subset(sp.data, focal %in% lambda.values$sp & competitor %in% lambda.values$sp)
```

Finally, set initial values for e (competitive effects) and r (competitive responses), as well as their lower and upper bounds

```{r}
r.values <- rep(1,nrow(lambda.values))
e.values <- rep(1,nrow(lambda.values))

r.lower.bound <- rep(0, times=nrow(lambda.values))
r.upper.bound <- rep(1e2, times=nrow(lambda.values))
e.lower.bound <- r.lower.bound
e.upper.bound <- r.upper.bound
sigma.lower.bound <- 0.0000000001
sigma.upper.bound <- 1
```

We can now initialize the results data structure, a list in which each component will consist of the estimates from an optimization method.

```{r}
ER.list <- list()
for(i.method in 1:length(optim.methods)){
  ER.list[[i.method]] <- list(lambda = NA,
                                 lambda.lower.error = NA,
                                 lambda.upper.error = NA,
                                 response = NA,
                                 response.lower.error = NA,
                                 response.upper.error = NA,
                                 effect = NA,
                                 effect.lower.error = NA,
                                 effect.upper.error = NA,
                                 sigma = NA,
                                 lambda.cov = NA,
                                 lambda.cov.lower.error = NA,
                                 lambda.cov.upper.error = NA,
                                 response.cov = NA,
                                 response.cov.lower.error = NA,
                                 response.cov.upper.error = NA,
                                 effect.cov = NA,
                                 effect.cov.lower.error = NA,
                                 effect.cov.upper.error = NA,
                                 log.likelihood = NA)

}
names(ER.list) <- optim.methods
```

In the main loop, we 1) call the \code{ER_optimize} function with each of the selected optimization methods, 2) store the resulting values in the list we just created. Note that, in the function call, we omit the arguments related to the inclusion of covariates, because these have a default \code{NULL} value. These arguments (e.g. \code{lambda.cov}, \code{r.cov}, \code{e.cov}, and their associated errors) are nevertheless returned as NA from the function, and for completeness we also retrieve them.

```{r}
for(i.method in 1:length(optim.methods)){
  
  # 1) call optimization function
  param.results <- ER_optimize(lambda.vector = lambda.values$lambda,
                               e.vector = e.values,
                               r.vector = r.values,
                               sigma = sigma,
                               lambda.lower.bound = lambda.lower.bound,
                               lambda.upper.bound = lambda.upper.bound,
                               e.lower.bound = e.lower.bound,
                               e.upper.bound = e.upper.bound,
                               r.lower.bound = r.lower.bound,
                               r.upper.bound = r.upper.bound,
                               sigma.lower.bound = sigma.lower.bound,
                               sigma.upper.bound = sigma.upper.bound,
                               effect.response.model = effect.response.model,
                               optim.method = optim.methods[i.method],
                               sp.data = sp.data,
                               optimize.lambda = optimize.lambda,
                               generate.errors = generate.errors,
                               bootstrap.samples = bootstrap.samples)
  
  # 2) store results
  ER.list[[optim.methods[i.method]]]$lambda <- param.results$lambda
  ER.list[[optim.methods[i.method]]]$lambda.lower.error <- param.results$lambda.lower.error
  ER.list[[optim.methods[i.method]]]$lambda.upper.error <- param.results$lambda.upper.error
  ER.list[[optim.methods[i.method]]]$response <- param.results$response
  ER.list[[optim.methods[i.method]]]$response.lower.error <- param.results$response.lower.error
  ER.list[[optim.methods[i.method]]]$response.upper.error <- param.results$response.upper.error
  ER.list[[optim.methods[i.method]]]$effect <- param.results$effect
  ER.list[[optim.methods[i.method]]]$effect.lower.error <- param.results$effect.lower.error
  ER.list[[optim.methods[i.method]]]$effect.upper.error <- param.results$effect.upper.error
  ER.list[[optim.methods[i.method]]]$sigma <- param.results$sigma
  ER.list[[optim.methods[i.method]]]$lambda.cov <- param.results$lambda.cov
  ER.list[[optim.methods[i.method]]]$lambda.cov.lower.error <- param.results$lambda.cov.lower.error
  ER.list[[optim.methods[i.method]]]$lambda.cov.upper.error <- param.results$lambda.cov.upper.error
  ER.list[[optim.methods[i.method]]]$response.cov <- param.results$response.cov
  ER.list[[optim.methods[i.method]]]$response.cov.lower.error <- param.results$response.cov.lower.error
  ER.list[[optim.methods[i.method]]]$response.cov.upper.error <- param.results$response.cov.upper.error
  ER.list[[optim.methods[i.method]]]$effect.cov <- param.results$effect.cov
  ER.list[[optim.methods[i.method]]]$effect.cov.lower.error <- param.results$effect.cov.lower.error
  ER.list[[optim.methods[i.method]]]$effect.cov.upper.error <- param.results$effect.cov.upper.error
  ER.list[[optim.methods[i.method]]]$log.likelihood <- param.results$log.likelihood
}

if(write.results){
  save(ER.list,file = "./results/effect_response_estimates.Rdata")
}

```


