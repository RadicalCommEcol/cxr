---
title: "Plot pairwise species coexistence"
output: rmarkdown::html_vignette
author: cxr team
vignette: >
  %\VignetteIndexEntry{Multi-species parameter optimization}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

In this document, we draw the coexistence region of our plant community and locate every pair of species in this region. For that, we use the parameters previously calculated for each species (see vignette \code{Multi-species parameter optimization}), and the germination and survival rates, which are both stored with the package. 

```{r}
library(cxr)
library(ggplot2)
data(param_estimates)
data(species_rates)
```

First, compile the parameters from the original results, which are in a nested list. We will use the estimates from the most complex model (BH_5), and the optimization method ...

```{r}
sp.names <- sort(unique(names(param.matrices)))
alpha.matrix <- matrix(0,nrow = length(sp.names),ncol = length(sp.names))
lambda.values <- numeric(length(sp.names))
names(lambda.values) <- sp.names
rownames(alpha.matrix) <- colnames(alpha.matrix) <- sp.names
# from which model and optimization method are we gathering parameters
estimates.model <- "BH_4"
estimates.method <- "optim_NM"
for(i.sp in 1:length(sp.names)){
  lambda.values[i.sp] <- param.matrices[[i.sp]][[estimates.model]][[estimates.method]]$lambda
  alpha.matrix[i.sp,] <- param.matrices[[i.sp]][[estimates.model]][[estimates.method]]$alpha[sp.names]
}
# for(i.sp in 1:length(sp.names)){
#   lambda.values[i.sp] <- param_estimates[[i.sp]][[estimates.model]][[estimates.method]]$lambda
#   alpha.matrix[i.sp,] <- param_estimates[[i.sp]][[estimates.model]][[estimates.method]]$alpha[sp.names]
# }
```

Now, we build a dataframe with all unique pairwise combinations of species

```{r}
# function from https://stackoverflow.com/questions/17171148/non-redundant-version-of-expand-grid
expand.grid.unique <- function(x, y, include.equals=FALSE)
{
  x <- unique(x)
  y <- unique(y)
  g <- function(i){
    z <- setdiff(y, x[seq_len(i-include.equals)])
    if(length(z)) cbind(x[i], z, deparse.level=0)
  }
  do.call(rbind, lapply(seq_along(x), g))
}

pairwise.ratios <- as.data.frame(expand.grid.unique(sp.names,sp.names,include.equals = FALSE),stringsAsFactors = FALSE)
names(pairwise.ratios) <- c("sp1","sp2")
pairwise.ratios$fitness.ratio <- 0
pairwise.ratios$niche.overlap <- 0
```

and compute the average fitness ratio and niche overlap between pairs

```{r}
# gather fitness ratio/niche overlap between each pair
for(i.pair in 1:nrow(pairwise.ratios)){
  my.sp <- c(pairwise.ratios$sp1[i.pair],pairwise.ratios$sp2[i.pair])
  ########### TEST ONLY!!! remove ABS
  my.matrix <- abs(alpha.matrix[my.sp,my.sp])
  ###########
  pairwise.ratios$fitness.ratio[i.pair] <- AvgFitnessRatio(lambda = lambda.values[my.sp],
                                                           germ.rate = species_rates$germination[species_rates$code %in% my.sp],
                                                           survival.rate = species_rates$`seed survival`[species_rates$code %in% my.sp],
                                                           pair.matrix = my.matrix)[[3]]
  pairwise.ratios$niche.overlap[i.pair] <- NicheOverlap(pair.matrix = my.matrix)
}
```

For making the plot, we adapt, simplified, the great example from Ke and Letten (2018), in which they show the regions leading to coexistence, exclusion, and priority effects between species pairs.

First, generate a dataframe for the limits of the different regions, and specify the axes limits

```{r}
x <- seq(1,-1,by=-0.001)
y1 <- 1/(1-x)
y2 <- 1-x

lines <- data.frame(x = c(x,x), 
                    y = c(y1,y2), 
                    fun = c(rep("y1", times = length(seq(1, -1, by=-0.001))), 
                            rep("y2", times = length(seq(1, -1, by=-0.001)))))
my.lim.x = 0.5
my.lim.y = 1.7
```

and the code for the plot

```{r}
coex.plot <- ggplot() + 
  geom_line(data = lines, aes(x = x, y = y,linetype = fun,group = fun), col = "black") +
  # grid lines
  geom_abline(intercept = 0, slope = 0, lty = 2, col = "darkgrey") +
  geom_vline(xintercept = 0, lty = 2, col = "darkgrey") +
  # points
  geom_point(data = pairwise.ratios, aes(x = (1 - niche.overlap), y = log(fitness.ratio))) +
  # log-scale
  scale_y_log10() +
  # # trim to desired coords
  coord_cartesian(expand = c(0, 0),
                  xlim = c(-my.lim.x,my.lim.x),
                  ylim = c(1/my.lim.y, my.lim.y)) +
  # axes, legend, etc
  xlab(expression(paste("(1 - ", rho, " )", sep = ""))) + 
  ylab(expression(paste("Fitness ratio ( ", frac(italic(f[2]), italic(f[1])), " )", sep=""))) +
  theme(legend.position = "none", 
        axis.title.y = element_text(angle = 90), 
        axis.title = element_text(size = 20)) +
  NULL
coex.plot
```
 
 