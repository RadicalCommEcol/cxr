---
title: "Plot pairwise species coexistence"
output: rmarkdown::html_vignette
author: cxr team
vignette: >
  %\VignetteIndexEntry{Coexistence plot}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

In this document, we draw the coexistence region of our plant community and locate every pair of species in this region. For that, we use the parameters previously calculated for each species (see vignette \code{Multi-species parameter optimization}), and the germination and survival rates, which are both stored with the package. 

```{r}
library(cxr)
data(param_estimates)
data(species_rates)
```

First, compile the parameters from the original results, which are in a nested list. We will use the estimates from the most complex model (BH_5), and the optimization method ...

```{r}
sp.names <- sort(unique(names(param_estimates)))
alpha.matrix <- matrix(0,nrow = length(sp.names),ncol = length(sp.names))
lambda.values <- numeric(length(sp.names))
names(lambda.values) <- sp.names
rownames(alpha.matrix) <- colnames(alpha.matrix) <- sp.names
# from which model and optimization method are we gathering parameters
estimates.model <- "BH_5"
estimates.method <- "optim_L-BFGS-B"
for(i.sp in 1:length(sp.names)){
  lambda.values[i.sp] <- param_estimates[[i.sp]][[estimates.model]][[estimates.method]]$lambda
  alpha.matrix[i.sp,] <- param_estimates[[i.sp]][[estimates.model]][[estimates.method]]$alpha[sp.names]
}
```

Now, we build a dataframe with all unique pairwise combinations of species

```{r}
# function from https://stackoverflow.com/questions/17171148/non-redundant-version-of-expand-grid
expand.grid.unique <- function(x, y, include.equals=FALSE)
{
  x <- unique(x)
  y <- unique(y)
  g <- function(i){
    z <- setdiff(y, x[seq_len(i-include.equals)])
    if(length(z)) cbind(x[i], z, deparse.level=0)
  }
  do.call(rbind, lapply(seq_along(x), g))
}

pairwise.ratios <- as.data.frame(expand.grid.unique(sp.names,sp.names,include.equals = FALSE),stringsAsFactors = FALSE)
names(pairwise.ratios) <- c("sp1","sp2")
pairwise.ratios$fitness.ratio <- 0
pairwise.ratios$niche.overlap <- 0
```

and compute the average fitness ratio and niche overlap between pairs

```{r}
# gather fitness ratio/niche overlap between each pair
for(i.pair in 1:nrow(pairwise.ratios)){
  my.sp <- c(pairwise.ratios$sp1[i.pair],pairwise.ratios$sp2[i.pair])
  my.matrix <- alpha.matrix[my.sp,my.sp]
  
  pairwise.ratios$fitness.ratio[i.pair] <- AvgFitnessRatio(lambda = lambda.values[my.sp],
                                                           germ.rate = species_rates$germination[species_rates$code %in% my.sp],
                                                           survival.rate = species_rates$`seed survival`[species_rates$code %in% my.sp],
                                                           pair.matrix = my.matrix)[[3]]
  pairwise.ratios$niche.overlap[i.pair] <- NicheOverlap(pair.matrix = my.matrix)
}

pairwise.ratios$pair.ID <- paste(pairwise.ratios$sp1,"_",pairwise.ratios$sp2,sep="")

```

For making the plot, we adapt, simplified, the great example from Ke and Letten (2018), in which they show the regions leading to coexistence, exclusion, and priority effects between species pairs.

First, generate a dataframe for the limits of the different regions, and specify the axes limits. In this example, we focus on species pairs that are close to the region of coexistence. Many species pairs display wide average fitness ratios, falling clearly on the exclusion areas.

```{r}
x <- seq(1,-1,by=-0.001)
y1 <- 1/(1-x)
y2 <- 1-x

lines <- data.frame(x = c(x,x), 
                    y = c(y1,y2), 
                    fun = c(rep("y1", times = length(seq(1, -1, by=-0.001))), 
                            rep("y2", times = length(seq(1, -1, by=-0.001)))))
my.lim.x = 0.5
my.lim.y = 2
```

the code for the plot itself is

```{r echo=FALSE}

coex.plot <- ggplot2::ggplot() + 
  ggplot2::geom_line(data = lines, ggplot2::aes(x = x, y = y,linetype = fun,group = fun), col = "black") +
  # grid lines
  ggplot2::geom_abline(intercept = 0, slope = 0, lty = 2, col = "darkgrey") +
  ggplot2::geom_vline(xintercept = 0, lty = 2, col = "darkgrey") +
  # points
  ggplot2::geom_point(data = pairwise.ratios, ggplot2::aes(x = (1 - niche.overlap), y = log(fitness.ratio))) +
  ggplot2::geom_text(data = pairwise.ratios, ggplot2::aes(x = (1 - niche.overlap), y = log(fitness.ratio), label = pair.ID), hjust = 0, nudge_y = -0.01, nudge_x = 0.01, check_overlap = TRUE, size = 3)+
  # log-scale
  ggplot2::scale_y_log10() +
  # # trim to desired coords
  ggplot2::coord_cartesian(expand = c(0, 0),
                  xlim = c(-my.lim.x,my.lim.x),
                  ylim = c(1/my.lim.y, my.lim.y)) +
    # ggplot2::coord_cartesian(expand = c(0, 0),
    #               xlim = c(-my.lim.x,my.lim.x)) +
  # axes, legend, etc
  ggplot2::xlab(expression(paste("(1 - ", rho, " )", sep = ""))) + 
  ggplot2::ylab(expression(paste("Fitness ratio ( ", frac(italic(f[2]), italic(f[1])), " )", sep=""))) +
  ggplot2::theme(legend.position = "none", 
        axis.title.y = ggplot2::element_text(angle = 90), 
        axis.title = ggplot2::element_text(size = 20)) +
  NULL
coex.plot
```
 
 