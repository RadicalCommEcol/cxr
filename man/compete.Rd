% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compete.R
\name{compete}
\alias{compete}
\title{Calculates pairwise competitive effects between species}
\usage{
compete(focal, fitness, comp_matrix, covariates = NULL, model = NULL,
  drop0 = FALSE, log = TRUE, op = 25, method = "L-BFGS-B",
  lower1 = -Inf, upper1 = Inf, control1 = list(), gr1 = NULL,
  hessian1 = TRUE, lower2 = -Inf, upper2 = Inf, control2 = list(),
  gr2 = NULL, hessian2 = TRUE, lower3 = -Inf, upper3 = Inf,
  control3 = list(), gr3 = NULL, hessian3 = TRUE, lower4 = -Inf,
  upper4 = Inf, control4 = list(), gr4 = NULL, hessian4 = TRUE,
  lower5 = -Inf, upper5 = Inf, control5 = list(), gr5 = NULL,
  hessian5 = TRUE)
}
\arguments{
\item{focal}{vector with the focal species name of each observation}

\item{fitness}{Vector of the reproductive success or biomass or any other fitness measure of each observation}

\item{comp_matrix}{data.frame with as many columns as competitor species. Each cell is the number of competitors per observtion}

\item{covariates}{data.frame with as many columns as covariates measured.}

\item{model}{you can provide a function with a model to test if you don't like the default. This is not implemented yet. 
In any case models need to have the same initial par's as the ones implemented to be easy to plug.}

\item{drop0}{logical. Should observations with zero fitness be discarded?}

\item{log}{logical. Should fitnes be loged. Forced to be TRUE for now. 
For accepting non log fitness, the dnorm has to be modified in the models.}

\item{op}{number of iterations to ptimize the models.}

\item{method}{Options passed to `optim()` Default "L-BFGS-B".}

\item{lower1}{Options passed to `optim()` One value per par. For model one it needs 2 values.}

\item{upper1}{Options passed to `optim()` One value per par. For model one it needs 2 values.}

\item{control1}{Options passed to `optim()`. It should be a list.}

\item{gr1}{Options passed to `optim()`. Usually not used by us, but for completness.}

\item{hessian1}{Options passed to `optim()`. Default = TRUE. This provides SE for all params}

\item{lower2}{Options passed to `optim()` One value per par. For model two it needs 3 values.}

\item{upper2}{Options passed to `optim()` One value per par. For model two it needs 3 values.}

\item{control2}{Options passed to `optim()`. It should be a list.}

\item{gr2}{Options passed to `optim()`. Usually not used by us, but for completness.}

\item{hessian2}{Options passed to `optim()`. Default = TRUE. This provides SE for all params}

\item{lower3}{Options passed to `optim()` One value per par. For model three it needs 2+ncol(comp_matrix) values.}

\item{upper3}{Options passed to `optim()` One value per par. For model three it needs 2+ncol(comp_matrix) values.}

\item{control3}{Options passed to `optim()`. It should be a list.}

\item{gr3}{Options passed to `optim()`. Usually not used by us, but for completness.}

\item{hessian3}{Options passed to `optim()`. Default = TRUE. This provides SE.}

\item{lower4}{Options passed to `optim()` One value per par. For model four it needs 2+ncol(comp_matrix)+(2*ncol(covariates)) values.}

\item{upper4}{Options passed to `optim()` One value per par. For model four it needs 2+ncol(comp_matrix)+(2*ncol(covariates)) values.}

\item{control4}{Options passed to `optim()`. It should be a list.}

\item{gr4}{Options passed to `optim()`. Usually not used by us, but for completness.}

\item{hessian4}{Options passed to `optim()`. Default = TRUE. This provides SE.}

\item{lower5}{Options passed to `optim()` One value per par. For model five it needs 
2+ncol(comp_matrix)+ncol(covariates)+(ncol(comp_matrix)*ncol(covariates)) values.}

\item{upper5}{Options passed to `optim()` One value per par. For model five it needs 
2+ncol(comp_matrix)+ncol(covariates)+(ncol(comp_matrix)*ncol(covariates)) values.}

\item{control5}{Options passed to `optim()`. It should be a list.}

\item{gr5}{Options passed to `optim()`. Usually not used by us, but for completness.}

\item{hessian5}{Options passed to `optim()`. Default = TRUE. This provides SE.}
}
\value{
a list of estimated parameters for each model.
}
\description{
Calculates how reproduction decays with number of intra and inter-specific
 compettors. The idea is to fit a series of nested models. First model fits
 an intercept (lambda). Second model fits a common response to all competitors (alpha), 
 Third model fits a pairwise effct of competition (alpha_ij). And a fourth and fiveth models 
 fit covariates on lambda's and alpha's (l_cov and a_cov). Parameters obtained in each model serves as priors for the
 next model.
}
\details{
Useful control params are maxit=1000, or par scale (with as much elements as pars has the model)
}
\note{
This script follows previous methodology developed by Godoy et al 2014,
 Kraft et al. 2015 and Lanuza et al 2018 papers
}
\examples{

}
